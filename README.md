# Генерация словарей паролей

Программа генерирует словарь паролей по заданной маске и считает энтропию для данной маски.

## Требования к программе

*Формат входных данных*
`./a.out mask name_file_for_save_the_password_dictionary`

Маска должна иметь вид `{x-xx}+{x-xx}+…+{x-xx}`, при этом символ `xx`
обязательно по таблице `ascii` находится дальше символа `x`, а в каждых скобках
символы должны принадлежать одному из семи множеств: `{!-/}, {0-9}, {:-@},
{A-Z}, {[-``}, {a-z}` или `{{-~}`.
Также может быть указан файл, с который сохранится словарь паролей.
Если этот параметр не задан, результат будет направлен в стандартный поток
вывода.

## Формат выходных данных
Для вывода паролей и энтропии пароля используются два потока: словарь
выводится или в первый поток, или в файл, указанный на входе программы,
остальное отправляется в третий поток.
Алгоритм работы
1) Проверка введенных данных: количество аргументов в командной
строке, допустимость регулярного выражения, если указан файл,
возможность его открытия.
2) Создание двух массивов, имеющих размеры, равные количеству
букв.
3) Запись в первый массив значения (по `ascii`) символа минус один, с
которого начнется перебор, во второй – значение символа, по
который идет перебор.
4) С помощью цикла `do…while` инкрементирование каждого значения,
лежащего в первом массиве, и переход к следующему.
5) Если достигнут последний элемент, увеличение его и вывод
паролей, пока символ не станет больше соответствующего значения
во втором массиве.
6) Переход к предыдущему символу, инкрементирование его. Повтор
пунктов 4 – 6 до тех пор, пока первый символ не достигнет
максимального значения.
7) Подсчет энтропии заданной маски.

## Реализация

`size_t ft_strlen(const char *str)`

Функция считает количество символов в строке типа `char`.

`void ft_putchar_fd(char c, int fd)`

Функция выводит один символ типа char по файловому дескриптору `fd`.

`void ft_putchar_fd(char c, int fd)`

Функция выводит строку типа char по файловому дескриптору `fd`.

`void ft_bzero(void *str, size_t n)`

Устанавливает первые `n` байт области, начинающейся с `str`, в ноль `‘\0’`.

`void *ft_memalloc(size_t size)`

Работает как функция `malloc`, но устанавливает выделенную память в
нули.

`int ft_err_skobki(char *str)`

Проверяет полученную строку на допустимые значения, то есть лежащие
в отрезке от `0x20` до `0x7F`, и равенство количества открывающих и
закрывающих фигурных скобок. В случае ошибки возвращает `-1`.

`int ft_err_val(char *str)`

Поверяет полученную строку на правильное расположение всех символов
в соответствии с форматом входных данных. В случае ошибки возвращает `-1`,
иначе возвращает количество букв в будущем пароле.

`int ft_errors(char *str)`

Собирает всю информацию из функций `ft_err_skobki` и `ft_err_val`, если
одна из них возвращает `-1`, то она тоже вернет `-1`, если нет – возвращает
количество букв в будущем пароле.

`long double entropy(char *str, int len, int letter_count)`

Функция считает и возвращает значение энтропии пароля по переданной
маске.

`int main(int argc, char **argv)`

Собирает и обрабатывает всю информацию, возвращаемую функциями. В
случае отсутствия ошибок генерирует словарь паролей полным перебором,
исходя из значений заданной маски. После этого вызывает функцию подсчета
энтропии.

# Нормализация словарей паролей

Нормализация словаря паролей – это приведение словаря к списку
регулярных выражений. В данном случае они имеют вид `{x-xx}+{xxx}+…+{x-xx}`, при этом символ xx обязательно по таблице `ascii` находится
дальше символа `x`, а в каждых скобках символы принадлежат одному из семи
множеств: `{!-/}, {0-9}, {:-@}, {A-Z}, {[-``}, {a-z}` или `{{-~}`.

## Требования к программе
*Формат входных данных*
`./a.out name_file_with_dictionary | sort | uniq`

Утилита `sort` выводит строки в определенном порядке, она поможет
выстроить все маски по `ascii` таблице.

Утилита `uniq` осуществляет вывод и удаление из вывода повторяющихся
строк.

## Формат выходных данных

Вывод масок производится или в стандартный поток вывода, или в
указанный файл. Обычно в нормализованном словаре используют регулярные
выражения, но в данном случае был разработан упрощенный вариант
регулярных выражений, делающий процесс наиболее наглядным для
понимания.

## Алгоритм работы программы

1) Проверка введенных данных: количество аргументов в командной
строке, возможность открытия указанного файла.
2) Построчное считывание паролей из файла.
3) Проверка принадлежности каждого символа пароля одному из
множеств: `{!-/}, {0-9}, {:-@}, {A-Z}, {[-``}, {a-z}` или `{{-~}`.
4) Вывод результата на экран.

## Реализация

`size_t ft_strlen(const char *str)`

Функция считает количество символов в строке типа `char`.

`void ft_putchar_fd(char c, int fd)`

Функция выводит один символ типа char в стандартный поток вывода.

`void ft_putchar_fd(char c, int fd)`

Функция выводит строку типа `char` в стандартный поток вывода.

`int main(int argc, char **argv)`

В случае отсутствия ошибок (с количеством вводимых параметров и
открытием файла) считывает из файла функцией `getline` построчно и для
каждого символа пароля выводит отрезок, к которому он пренадлежит по
таблице `ascii`. Если встретится символ не из отрезка от `0x20` до `0x7F`, выводится
ошибка.
